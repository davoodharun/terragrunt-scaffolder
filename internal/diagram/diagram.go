package diagram

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/davoodharun/terragrunt-scaffolder/internal/config"
	"github.com/davoodharun/terragrunt-scaffolder/internal/logger"
	"gopkg.in/yaml.v3"
)

// GenerateDiagram generates Mermaid diagrams for all stacks
func GenerateDiagram() error {
	logger.Info("Generating infrastructure diagrams")

	// Read TGS config to get subscription and environment structure
	tgsConfig, err := readTGSConfig()
	if err != nil {
		return fmt.Errorf("failed to read TGS config: %w", err)
	}

	// Create diagrams directory in .infrastructure if it doesn't exist
	outputDir := filepath.Join(".infrastructure", "diagrams")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create diagrams directory: %w", err)
	}

	// Generate tree diagrams that show the folder structure for each stack
	stacks, err := GenerateTreeDiagram(tgsConfig, outputDir)
	if err != nil {
		return fmt.Errorf("failed to generate tree diagrams: %w", err)
	}

	// Log created files
	if len(stacks) == 1 {
		logger.Success("Generated folder structure tree diagram for stack: %s", stacks[0])
	} else {
		logger.Success("Generated folder structure tree diagrams for %d stacks", len(stacks))
		for _, stack := range stacks {
			logger.Info("  - %s", stack)
		}
	}

	// Track which stacks we've processed to avoid duplicates
	processedStacks := make(map[string]bool)

	// Generate diagrams for each environment using its specified stack
	for _, sub := range tgsConfig.Subscriptions {
		for _, env := range sub.Environments {
			// Use the stack specified in the environment config, default to "main" if not specified
			stackName := "main"
			if env.Stack != "" {
				stackName = env.Stack
			}

			// Skip if we've already processed this stack for this environment
			key := fmt.Sprintf("%s_%s", stackName, env.Name)
			if processedStacks[key] {
				continue
			}
			processedStacks[key] = true

			if err := generateMermaidDiagram(stackName, tgsConfig, env.Name); err != nil {
				return fmt.Errorf("failed to generate diagram for stack %s, environment %s: %w", stackName, env.Name, err)
			}

			logger.Info("Generated diagram for stack %s, environment %s", stackName, env.Name)
		}
	}

	logger.Info("Generated infrastructure diagrams in .infrastructure/diagrams/ directory")
	return nil
}

// GenerateTreeDiagram creates markdown files with folder structure trees for each stack
func GenerateTreeDiagram(tgsConfig *config.TGSConfig, outputDir string) ([]string, error) {
	// Collect all stacks
	stacks := make(map[string]bool)
	for _, sub := range tgsConfig.Subscriptions {
		for _, env := range sub.Environments {
			stackName := "main"
			if env.Stack != "" {
				stackName = env.Stack
			}
			stacks[stackName] = true
		}
	}

	// Create a slice to track which stacks we've processed
	var processedStacks []string

	// Process each stack
	for stackName := range stacks {
		// Create the file for the tree diagram with stack name in filename
		treeFilename := fmt.Sprintf("folder_structure_%s.md", stackName)
		treePath := filepath.Join(outputDir, treeFilename)

		var content strings.Builder

		// Add header
		content.WriteString(fmt.Sprintf("# Infrastructure Folder Structure - %s Stack\n\n", stackName))
		content.WriteString("This document shows the folder structure of the infrastructure scaffold generated by TGS (Terraform Scaffold Generator).\n\n")

		// Add folder structure tree section
		content.WriteString("## Folder Structure\n\n")
		content.WriteString("```\n")
		content.WriteString(".infrastructure/\n")
		content.WriteString("├── _components/                      # Component templates\n")

		// Add components for this stack
		content.WriteString(fmt.Sprintf("│   └── %s/                     # Components for %s stack\n", stackName, stackName))

		// Attempt to read the stack configuration to get components
		mainConfig, err := readStackConfig(stackName)
		if err == nil {
			// Get all component names and sort them
			var componentNames []string
			for compName := range mainConfig.Stack.Components {
				componentNames = append(componentNames, compName)
			}

			if len(componentNames) > 0 {
				// For all components except the last one
				for _, compName := range componentNames[:len(componentNames)-1] {
					content.WriteString(fmt.Sprintf("│       ├── %s/\n", compName))
				}
				// For the last component
				content.WriteString(fmt.Sprintf("│       └── %s/\n", componentNames[len(componentNames)-1]))
			}
		}

		// Add architecture section
		content.WriteString("├── architecture/                    # Deployed architecture by stack\n")
		content.WriteString(fmt.Sprintf("│   └── %s/                     # %s stack architecture\n", stackName, stackName))

		// Collect subscriptions that use this stack
		var stackSubscriptions []string
		for subName, sub := range tgsConfig.Subscriptions {
			for _, env := range sub.Environments {
				envStackName := "main"
				if env.Stack != "" {
					envStackName = env.Stack
				}

				if envStackName == stackName {
					// Add this subscription if not already present
					found := false
					for _, s := range stackSubscriptions {
						if s == subName {
							found = true
							break
						}
					}
					if !found {
						stackSubscriptions = append(stackSubscriptions, subName)
					}
				}
			}
		}

		// Process each subscription for this stack
		for i, subName := range stackSubscriptions {
			// Use correct tree characters based on position
			prefix := "├── "
			if i == len(stackSubscriptions)-1 {
				prefix = "└── "
			}

			content.WriteString(fmt.Sprintf("│       %s%s/                # %s subscription\n", prefix, subName, subName))

			// Get the subscription data
			sub := tgsConfig.Subscriptions[subName]

			// Attempt to read the stack configuration to get regions
			if err == nil {
				regions := make([]string, 0, len(mainConfig.Stack.Architecture.Regions))
				for region := range mainConfig.Stack.Architecture.Regions {
					regions = append(regions, region)
				}

				// Process each region
				for j, region := range regions {
					// Use correct tree characters based on position
					regionPrefix := "├── "
					if j == len(regions)-1 {
						regionPrefix = "└── "
					}

					// If this is the last subscription, we need to adjust the prefix
					if i == len(stackSubscriptions)-1 {
						content.WriteString(fmt.Sprintf("│           %s%s/           # %s region\n", regionPrefix, region, region))
					} else {
						content.WriteString(fmt.Sprintf("│       │   %s%s/           # %s region\n", regionPrefix, region, region))
					}

					// Find environments for this subscription and stack
					var envs []string
					for _, envConfig := range sub.Environments {
						if envConfig.Stack == stackName || (envConfig.Stack == "" && stackName == "main") {
							envs = append(envs, envConfig.Name)
						}
					}

					// Process each environment
					for k, envName := range envs {
						// Use correct tree characters based on position
						envPrefix := "├── "
						if k == len(envs)-1 {
							envPrefix = "└── "
						}

						// Adjust the prefix based on position in the tree
						if i == len(stackSubscriptions)-1 {
							if j == len(regions)-1 {
								content.WriteString(fmt.Sprintf("│               %s%s/      # %s environment\n", envPrefix, envName, envName))

								// Add components for this environment
								if regionComponents, ok := mainConfig.Stack.Architecture.Regions[region]; ok {
									// Show components within this environment
									for l, comp := range regionComponents {
										compPrefix := "├── "
										if l == len(regionComponents)-1 {
											compPrefix = "└── "
										}

										// Add component
										content.WriteString(fmt.Sprintf("│               │   %s%s/   # %s component\n",
											compPrefix, comp.Component, comp.Component))

										// If the component has apps, add them too
										if len(comp.Apps) > 0 {
											for m, app := range comp.Apps {
												appPrefix := "├── "
												if m == len(comp.Apps)-1 {
													appPrefix = "└── "
												}

												content.WriteString(fmt.Sprintf("│               │   │   %s%s/  # %s app\n",
													appPrefix, app, app))
											}
										}
									}
								}
							} else {
								content.WriteString(fmt.Sprintf("│           │   %s%s/      # %s environment\n", envPrefix, envName, envName))

								// Add components for this environment
								if regionComponents, ok := mainConfig.Stack.Architecture.Regions[region]; ok {
									// Show components within this environment
									for l, comp := range regionComponents {
										compPrefix := "├── "
										if l == len(regionComponents)-1 {
											compPrefix = "└── "
										}

										// Add component
										content.WriteString(fmt.Sprintf("│           │   │   %s%s/   # %s component\n",
											compPrefix, comp.Component, comp.Component))

										// If the component has apps, add them too
										if len(comp.Apps) > 0 {
											for m, app := range comp.Apps {
												appPrefix := "├── "
												if m == len(comp.Apps)-1 {
													appPrefix = "└── "
												}

												content.WriteString(fmt.Sprintf("│           │   │   │   %s%s/  # %s app\n",
													appPrefix, app, app))
											}
										}
									}
								}
							}
						} else {
							if j == len(regions)-1 {
								content.WriteString(fmt.Sprintf("│       │       %s%s/      # %s environment\n", envPrefix, envName, envName))

								// Add components for this environment
								if regionComponents, ok := mainConfig.Stack.Architecture.Regions[region]; ok {
									// Show components within this environment
									for l, comp := range regionComponents {
										compPrefix := "├── "
										if l == len(regionComponents)-1 {
											compPrefix = "└── "
										}

										// Add component
										content.WriteString(fmt.Sprintf("│       │       │   %s%s/   # %s component\n",
											compPrefix, comp.Component, comp.Component))

										// If the component has apps, add them too
										if len(comp.Apps) > 0 {
											for m, app := range comp.Apps {
												appPrefix := "├── "
												if m == len(comp.Apps)-1 {
													appPrefix = "└── "
												}

												content.WriteString(fmt.Sprintf("│       │       │   │   %s%s/  # %s app\n",
													appPrefix, app, app))
											}
										}
									}
								}
							} else {
								content.WriteString(fmt.Sprintf("│       │   │   %s%s/      # %s environment\n", envPrefix, envName, envName))

								// Add components for this environment
								if regionComponents, ok := mainConfig.Stack.Architecture.Regions[region]; ok {
									// Show components within this environment
									for l, comp := range regionComponents {
										compPrefix := "├── "
										if l == len(regionComponents)-1 {
											compPrefix = "└── "
										}

										// Add component
										content.WriteString(fmt.Sprintf("│       │   │   │   %s%s/   # %s component\n",
											compPrefix, comp.Component, comp.Component))

										// If the component has apps, add them too
										if len(comp.Apps) > 0 {
											for m, app := range comp.Apps {
												appPrefix := "├── "
												if m == len(comp.Apps)-1 {
													appPrefix = "└── "
												}

												content.WriteString(fmt.Sprintf("│       │   │   │   │   %s%s/  # %s app\n",
													appPrefix, app, app))
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		// Add config section
		content.WriteString("├── config/                          # Configuration files\n")
		content.WriteString("│   ├── global.hcl                   # Global configuration\n")
		content.WriteString(fmt.Sprintf("│   └── %s/                     # Configuration for %s stack\n", stackName, stackName))
		content.WriteString("│       └── environments/           # Environment-specific configs\n")

		// Attempt to read the stack configuration to get app settings
		if err == nil {
			// Collect app settings and policy files components
			var appSettingsComps []string
			var policyFilesComps []string

			for compName, comp := range mainConfig.Stack.Components {
				if comp.AppSettings {
					appSettingsComps = append(appSettingsComps, compName)
				}
				if comp.PolicyFiles {
					policyFilesComps = append(policyFilesComps, compName)
				}
			}

			// Generate app settings entries
			for i, compName := range appSettingsComps {
				if i < len(appSettingsComps)-1 || len(policyFilesComps) > 0 {
					// Use ├── if not the last item or if policy files follow
					content.WriteString(fmt.Sprintf("│       ├── app_settings_%s/      # App settings for %s\n", compName, compName))
				} else {
					// Use └── for the last item if no policy files follow
					content.WriteString(fmt.Sprintf("│       └── app_settings_%s/      # App settings for %s\n", compName, compName))
				}
			}

			// Generate policy files entries
			for i, compName := range policyFilesComps {
				if i < len(policyFilesComps)-1 {
					// Use ├── if not the last item
					content.WriteString(fmt.Sprintf("│       ├── policy_files_%s/      # Policy files for %s\n", compName, compName))
				} else {
					// Use └── for the last item
					content.WriteString(fmt.Sprintf("│       └── policy_files_%s/      # Policy files for %s\n", compName, compName))
				}
			}
		}

		// Add diagrams folder
		content.WriteString("├── diagrams/                        # Infrastructure diagrams\n")
		content.WriteString(fmt.Sprintf("│   └── folder_structure_%s.md      # This file\n", stackName))

		content.WriteString("└── root.hcl                         # Root configuration\n")
		content.WriteString("```\n\n")

		// Add usage section
		content.WriteString("## Usage\n\n")
		content.WriteString("To apply this infrastructure, use Terragrunt:\n\n")
		content.WriteString("```bash\n")
		content.WriteString(fmt.Sprintf("cd .infrastructure/architecture/%s/{subscription}/{region}/{environment}/{component}\n", stackName))
		content.WriteString("terragrunt init\n")
		content.WriteString("terragrunt plan\n")
		content.WriteString("terragrunt apply\n")
		content.WriteString("```\n\n")

		content.WriteString("## Project Structure\n\n")
		content.WriteString("- **_components**: Contains the Terraform modules for each component\n")
		content.WriteString("- **architecture**: Terragrunt configuration structure for each environment\n")
		content.WriteString("- **config**: Global and environment-specific configuration files\n")
		content.WriteString("- **diagrams**: Infrastructure visualization diagrams\n")

		// Write the content to the file
		if err := writeFile(treePath, content.String()); err != nil {
			return processedStacks, fmt.Errorf("failed to write tree diagram for stack %s: %w", stackName, err)
		}

		// Add this stack to the list of processed stacks
		processedStacks = append(processedStacks, stackName)
	}

	return processedStacks, nil
}

// writeFile creates a file with the given content
func writeFile(path string, content string) error {
	// Ensure the parent directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	return os.WriteFile(path, []byte(content), 0644)
}

// readStackConfig reads a specific stack configuration
func readStackConfig(stackName string) (*config.MainConfig, error) {
	stacksDir := filepath.Join(".tgs", "stacks")
	stackPath := filepath.Join(stacksDir, fmt.Sprintf("%s.yaml", stackName))

	data, err := os.ReadFile(stackPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read stack file %s: %w", stackPath, err)
	}

	var cfg config.MainConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse stack file %s: %w", stackPath, err)
	}

	return &cfg, nil
}

// readTGSConfig reads the tgs.yaml configuration
func readTGSConfig() (*config.TGSConfig, error) {
	configDir := ".tgs"
	configPath := filepath.Join(configDir, "tgs.yaml")

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read tgs.yaml: %w", err)
	}

	var cfg config.TGSConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("failed to parse tgs.yaml: %w", err)
	}

	return &cfg, nil
}
